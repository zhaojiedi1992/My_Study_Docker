%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{了解docker}}

\addto\captionsenglish{\renewcommand{\figurename}{图}}
\addto\captionsenglish{\renewcommand{\tablename}{表}}
\addto\captionsenglish{\renewcommand{\literalblockname}{列表}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{续上页}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{页}}

\setcounter{tocdepth}{0}



\title{My\_Study\_Docker Documentation}
\date{2018 年 09 月 29 日}
\release{v1.0}
\author{zhaojiedi1992@outlook.com}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{发布}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{docker的版本}
\label{\detokenize{_u4e86_u89e3docker/01-docker_u7684_u7248_u672c:docker}}\label{\detokenize{_u4e86_u89e3docker/01-docker_u7684_u7248_u672c::doc}}
docker分为2个版本，社区版本和企业版本。
\begin{itemize}
\item {} 
Community Edition(CE)

\item {} 
Enterprise Edition(EE)

\end{itemize}


\chapter{获取docker的ce版本}
\label{\detokenize{_u4e86_u89e3docker/02-_u83b7_u53d6docker_u7684ce_u7248_u672c::doc}}\label{\detokenize{_u4e86_u89e3docker/02-_u83b7_u53d6docker_u7684ce_u7248_u672c:dockerce}}

\section{OS需求}
\label{\detokenize{_u4e86_u89e3docker/02-_u83b7_u53d6docker_u7684ce_u7248_u672c:os}}\begin{itemize}
\item {} 
确保你启用的标准centos-extra仓库。

\item {} 
overlay2存储驱动推荐使用

\end{itemize}


\section{卸载老版本的docker}
\label{\detokenize{_u4e86_u89e3docker/02-_u83b7_u53d6docker_u7684ce_u7248_u672c:docker}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} sudo yum remove docker \PYG{l+s+se}{\PYGZbs{}}
                docker\PYGZhy{}client \PYG{l+s+se}{\PYGZbs{}}
                docker\PYGZhy{}client\PYGZhy{}latest \PYG{l+s+se}{\PYGZbs{}}
                docker\PYGZhy{}common \PYG{l+s+se}{\PYGZbs{}}
                docker\PYGZhy{}latest \PYG{l+s+se}{\PYGZbs{}}
                docker\PYGZhy{}latest\PYGZhy{}logrotate \PYG{l+s+se}{\PYGZbs{}}
                docker\PYGZhy{}logrotate \PYG{l+s+se}{\PYGZbs{}}
                docker\PYGZhy{}selinux \PYG{l+s+se}{\PYGZbs{}}
                docker\PYGZhy{}engine\PYGZhy{}selinux \PYG{l+s+se}{\PYGZbs{}}
                docker\PYGZhy{}engine
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{注解:}
docker 社区版本的包名字为docker-ce,使用yum remove docker-ce完成卸载。
\end{sphinxadmonition}


\section{设置按照需要的仓库}
\label{\detokenize{_u4e86_u89e3docker/02-_u83b7_u53d6docker_u7684ce_u7248_u672c:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} sudo yum install \PYGZhy{}y yum\PYGZhy{}utils \PYG{l+s+se}{\PYGZbs{}}
device\PYGZhy{}mapper\PYGZhy{}persistent\PYGZhy{}data \PYG{l+s+se}{\PYGZbs{}}
lvm2
\PYGZdl{} sudo yum\PYGZhy{}config\PYGZhy{}manager \PYG{l+s+se}{\PYGZbs{}}
    \PYGZhy{}\PYGZhy{}add\PYGZhy{}repo \PYG{l+s+se}{\PYGZbs{}}
    https://download.docker.com/linux/centos/docker\PYGZhy{}ce.repo

\PYGZdl{} sudo yum\PYGZhy{}config\PYGZhy{}manager \PYGZhy{}\PYGZhy{}enable docker\PYGZhy{}ce\PYGZhy{}edge
\PYGZdl{} sudo yum\PYGZhy{}config\PYGZhy{}manager \PYGZhy{}\PYGZhy{}enable docker\PYGZhy{}ce\PYGZhy{}test
\end{sphinxVerbatim}


\section{安装docker}
\label{\detokenize{_u4e86_u89e3docker/02-_u83b7_u53d6docker_u7684ce_u7248_u672c:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 按照默认版本}
\PYGZdl{} sudo yum install docker\PYGZhy{}ce

\PYG{c+c1}{\PYGZsh{} 按照指定版本}
\PYGZdl{} yum list docker\PYGZhy{}ce \PYGZhy{}\PYGZhy{}showduplicates \PYG{p}{\textbar{}} sort \PYGZhy{}r
\PYGZdl{} sudo yum install docker\PYGZhy{}ce\PYGZhy{}\PYGZlt{}VERSION STRING\PYGZgt{}

\PYG{c+c1}{\PYGZsh{} 启动docker服务}
\PYGZdl{} sudo systemctl start docker
\end{sphinxVerbatim}


\section{测试docker}
\label{\detokenize{_u4e86_u89e3docker/02-_u83b7_u53d6docker_u7684ce_u7248_u672c:id3}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 运行一个hello world}
\PYGZdl{} sudo docker run hello\PYGZhy{}world
\end{sphinxVerbatim}


\chapter{docker概念}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/01-docker_u6982_u5ff5::doc}}\label{\detokenize{_u5feb_u901f_u5165_u95e8/01-docker_u6982_u5ff5:docker}}

\section{docker优点}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/01-docker_u6982_u5ff5:id1}}\begin{description}
\item[{灵活}] \leavevmode
即使是最复杂的应用也可以集装箱化。

\item[{轻量级}] \leavevmode
容器利用并共享主机内核。

\item[{可互换}] \leavevmode
您可以即时部署更新和升级。

\item[{便携式}] \leavevmode
您可以在本地构建，部署到云，并在任何地方运行。

\item[{可扩展}] \leavevmode
您可以增加并自动分发容器副本。

\item[{可堆叠}] \leavevmode
您可以垂直和即时堆叠服务。

\end{description}


\section{容器和镜像}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/01-docker_u6982_u5ff5:id2}}
一个容器是一个镜像的运行，一个镜像是一个可执行的包，这里面包含应用运行的代码、运行时环境、依赖库和配置文件等。
一个容器是一个镜像的运行实例，一个镜像可以运行处多个实例的。


\section{容器和虚拟机}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/01-docker_u6982_u5ff5:id3}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{20}{40}|\X{20}{40}|}
\hline
\sphinxstyletheadfamily 
容器
&\sphinxstyletheadfamily 
虚拟机
\\
\hline
\noindent\sphinxincludegraphics{{Container2x}.png}
&
\noindent\sphinxincludegraphics{{VMx}.png}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\section{docker版本}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/01-docker_u6982_u5ff5:id4}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 查看docker版本}
docker \PYGZhy{}\PYGZhy{}version
Docker version \PYG{l+m}{17}.12.0\PYGZhy{}ce, build c97c6d6

\PYG{c+c1}{\PYGZsh{} 查看docker详细信息}
docker info
Containers: \PYG{l+m}{0}
Running: \PYG{l+m}{0}
Paused: \PYG{l+m}{0}
Stopped: \PYG{l+m}{0}
Images: \PYG{l+m}{0}
Server Version: \PYG{l+m}{17}.12.0\PYGZhy{}ce
Storage Driver: overlay2
...
\end{sphinxVerbatim}


\section{测试docker的安装}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/01-docker_u6982_u5ff5:id5}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 运行一个样例docker}
docker run hello\PYGZhy{}world
Unable to find image \PYG{l+s+s1}{\PYGZsq{}hello\PYGZhy{}world:latest\PYGZsq{}} locally
latest: Pulling from library/hello\PYGZhy{}world
ca4f61b1923c: Pull \PYG{n+nb}{complete}
Digest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7
Status: Downloaded newer image \PYG{k}{for} hello\PYGZhy{}world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.
...

\PYG{c+c1}{\PYGZsh{} 列出当前镜像列表}
docker image ls

\PYG{c+c1}{\PYGZsh{} 列出所有}
docker container ls \PYGZhy{}\PYGZhy{}all

CONTAINER ID     IMAGE           COMMAND      CREATED            STATUS
54f4984ed6a8     hello\PYGZhy{}world     \PYG{l+s+s2}{\PYGZdq{}/hello\PYGZdq{}}     \PYG{l+m}{20} seconds ago     Exited \PYG{o}{(}\PYG{l+m}{0}\PYG{o}{)} \PYG{l+m}{19} seconds ago
\end{sphinxVerbatim}


\chapter{容器}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668::doc}}\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:id1}}

\section{需要的环境}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:id2}}\begin{itemize}
\item {} 
docker\textgreater{}=1.13

\end{itemize}


\section{部署环境}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:id3}}
在过去，你如果部署一个python应用，你需要在你的计算机上安装python的运行时环境，且测试机器和生产环境还要一致的环境类型。
使用docker，你可以在应用程序的代码辅助python镜像，确保你的代码和运行时环境一起运行的。这些可一直的容器是由dockerfile定义的。


\section{容器样例}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:id4}}

\subsection{创建docker文件}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:docker}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 定义一个基础镜像}
\PYG{k}{FROM}\PYG{l+s}{ python:2.7\PYGZhy{}slim}

\PYG{c}{\PYGZsh{} 设置工作目录}
\PYG{k}{WORKDIR}\PYG{l+s}{ /app}

\PYG{c}{\PYGZsh{} copy当前目录到镜像的app目录}
\PYG{k}{ADD}\PYG{l+s}{ . /app}

\PYG{c}{\PYGZsh{} 使用pip安装软件}
\PYG{k}{RUN} pip install \PYGZhy{}\PYGZhy{}trusted\PYGZhy{}host pypi.python.org \PYGZhy{}r requirements.txt

\PYG{c}{\PYGZsh{} 暴露80端口为外部}
\PYG{k}{EXPOSE}\PYG{l+s}{ 80}

\PYG{c}{\PYGZsh{} 定义写环境变量}
\PYG{k}{ENV}\PYG{l+s}{ NAME World}

\PYG{c}{\PYGZsh{} 运行docker启动命令}
\PYG{k}{CMD}\PYG{l+s}{ [\PYGZdq{}python\PYGZdq{}, \PYGZdq{}app.py\PYGZdq{}]}
\end{sphinxVerbatim}


\subsection{准备requirements.txt文件}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:requirements-txt}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Flask
Redis
\end{sphinxVerbatim}


\subsection{准备app.py文件}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:app-py}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{flask} \PYG{k+kn}{import} \PYG{n}{Flask}
\PYG{k+kn}{from} \PYG{n+nn}{redis} \PYG{k+kn}{import} \PYG{n}{Redis}\PYG{p}{,} \PYG{n}{RedisError}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{socket}

\PYG{c+c1}{\PYGZsh{} Connect to Redis}
\PYG{n}{redis} \PYG{o}{=} \PYG{n}{Redis}\PYG{p}{(}\PYG{n}{host}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{redis}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{db}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{socket\PYGZus{}connect\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{socket\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{app} \PYG{o}{=} \PYG{n}{Flask}\PYG{p}{(}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}

\PYG{n+nd}{@app.route}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{hello}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{n}{visits} \PYG{o}{=} \PYG{n}{redis}\PYG{o}{.}\PYG{n}{incr}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{counter}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{except} \PYG{n}{RedisError}\PYG{p}{:}
        \PYG{n}{visits} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}i\PYGZgt{}cannot connect to Redis, counter disabled\PYGZlt{}/i\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}

    \PYG{n}{html} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}h3\PYGZgt{}Hello \PYGZob{}name\PYGZcb{}!\PYGZlt{}/h3\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}b\PYGZgt{}Hostname:\PYGZlt{}/b\PYGZgt{} \PYGZob{}hostname\PYGZcb{}\PYGZlt{}br/\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}b\PYGZgt{}Visits:\PYGZlt{}/b\PYGZgt{} \PYGZob{}visits\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{html}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NAME}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{world}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{hostname}\PYG{o}{=}\PYG{n}{socket}\PYG{o}{.}\PYG{n}{gethostname}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{visits}\PYG{o}{=}\PYG{n}{visits}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{app}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{host}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0.0.0.0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{port}\PYG{o}{=}\PYG{l+m+mi}{80}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{构建}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:id5}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ls
Dockerfile          app.py                  requirements.txt

\PYG{o}{[}root@iZ2ze3vsekthy9vqtndzefZ docker\PYG{o}{]}\PYG{c+c1}{\PYGZsh{} docker build \PYGZhy{}t friendlyhello .}
Sending build context to Docker daemon \PYG{l+m}{4}.608 kB
Step \PYG{l+m}{1}/7 : FROM python:2.7\PYGZhy{}slim
Trying to pull repository docker.io/library/python ...
\PYG{l+m}{2}.7\PYGZhy{}slim: Pulling from docker.io/library/python
be8881be8156: Pull \PYG{n+nb}{complete}
44247e56d488: Pull \PYG{n+nb}{complete}
ae1109c65233: Pull \PYG{n+nb}{complete}
97f741585990: Pull \PYG{n+nb}{complete}
Digest: sha256:9422cd48eb69711bb5feedbec8afd229f1409131f16daced947914938b37c811
Status: Downloaded newer image \PYG{k}{for} docker.io/python:2.7\PYGZhy{}slim
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 7302ff8cae7a
Step \PYG{l+m}{2}/7 : WORKDIR /app
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} ec5e5b5bb386
Removing intermediate container e4bc58b965b8
Step \PYG{l+m}{3}/7 : ADD . /app
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 3039e0d44f67
Removing intermediate container 23019655d916
Step \PYG{l+m}{4}/7 : RUN pip install \PYGZhy{}\PYGZhy{}trusted\PYGZhy{}host pypi.python.org \PYGZhy{}r requirements.txt
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Running in bbf16703da30

Collecting Flask \PYG{o}{(}from \PYGZhy{}r requirements.txt \PYG{o}{(}line \PYG{l+m}{1}\PYG{o}{)}\PYG{o}{)}
Downloading https://files.pythonhosted.org/packages/7f/e7/08578774ed4536d3242b14dacb4696386634607af824ea997202cd0edb4b/Flask\PYGZhy{}1.0.2\PYGZhy{}py2.py3\PYGZhy{}none\PYGZhy{}any.whl \PYG{o}{(}91kB\PYG{o}{)}
Collecting Redis \PYG{o}{(}from \PYGZhy{}r requirements.txt \PYG{o}{(}line \PYG{l+m}{2}\PYG{o}{)}\PYG{o}{)}
Downloading https://files.pythonhosted.org/packages/3b/f6/7a76333cf0b9251ecf49efff635015171843d9b977e4ffcf59f9c4428052/redis\PYGZhy{}2.10.6\PYGZhy{}py2.py3\PYGZhy{}none\PYGZhy{}any.whl \PYG{o}{(}64kB\PYG{o}{)}
Collecting itsdangerous\PYGZgt{}\PYG{o}{=}\PYG{l+m}{0}.24 \PYG{o}{(}from Flask\PYGZhy{}\PYGZgt{}\PYGZhy{}r requirements.txt \PYG{o}{(}line \PYG{l+m}{1}\PYG{o}{)}\PYG{o}{)}
Downloading https://files.pythonhosted.org/packages/dc/b4/a60bcdba945c00f6d608d8975131ab3f25b22f2bcfe1dab221165194b2d4/itsdangerous\PYGZhy{}0.24.tar.gz \PYG{o}{(}46kB\PYG{o}{)}
Collecting Jinja2\PYGZgt{}\PYG{o}{=}\PYG{l+m}{2}.10 \PYG{o}{(}from Flask\PYGZhy{}\PYGZgt{}\PYGZhy{}r requirements.txt \PYG{o}{(}line \PYG{l+m}{1}\PYG{o}{)}\PYG{o}{)}
Downloading https://files.pythonhosted.org/packages/7f/ff/ae64bacdfc95f27a016a7bed8e8686763ba4d277a78ca76f32659220a731/Jinja2\PYGZhy{}2.10\PYGZhy{}py2.py3\PYGZhy{}none\PYGZhy{}any.whl \PYG{o}{(}126kB\PYG{o}{)}
Collecting Werkzeug\PYGZgt{}\PYG{o}{=}\PYG{l+m}{0}.14 \PYG{o}{(}from Flask\PYGZhy{}\PYGZgt{}\PYGZhy{}r requirements.txt \PYG{o}{(}line \PYG{l+m}{1}\PYG{o}{)}\PYG{o}{)}
Downloading https://files.pythonhosted.org/packages/20/c4/12e3e56473e52375aa29c4764e70d1b8f3efa6682bef8d0aae04fe335243/Werkzeug\PYGZhy{}0.14.1\PYGZhy{}py2.py3\PYGZhy{}none\PYGZhy{}any.whl \PYG{o}{(}322kB\PYG{o}{)}
Collecting click\PYGZgt{}\PYG{o}{=}\PYG{l+m}{5}.1 \PYG{o}{(}from Flask\PYGZhy{}\PYGZgt{}\PYGZhy{}r requirements.txt \PYG{o}{(}line \PYG{l+m}{1}\PYG{o}{)}\PYG{o}{)}
Downloading https://files.pythonhosted.org/packages/34/c1/8806f99713ddb993c5366c362b2f908f18269f8d792aff1abfd700775a77/click\PYGZhy{}6.7\PYGZhy{}py2.py3\PYGZhy{}none\PYGZhy{}any.whl \PYG{o}{(}71kB\PYG{o}{)}
Collecting MarkupSafe\PYGZgt{}\PYG{o}{=}\PYG{l+m}{0}.23 \PYG{o}{(}from Jinja2\PYGZgt{}\PYG{o}{=}\PYG{l+m}{2}.10\PYGZhy{}\PYGZgt{}Flask\PYGZhy{}\PYGZgt{}\PYGZhy{}r requirements.txt \PYG{o}{(}line \PYG{l+m}{1}\PYG{o}{)}\PYG{o}{)}
Downloading https://files.pythonhosted.org/packages/4d/de/32d741db316d8fdb7680822dd37001ef7a448255de9699ab4bfcbdf4172b/MarkupSafe\PYGZhy{}1.0.tar.gz
Building wheels \PYG{k}{for} collected packages: itsdangerous, MarkupSafe
Running setup.py bdist\PYGZus{}wheel \PYG{k}{for} itsdangerous: started
Running setup.py bdist\PYGZus{}wheel \PYG{k}{for} itsdangerous: finished with status \PYG{l+s+s1}{\PYGZsq{}done\PYGZsq{}}
Stored in directory: /root/.cache/pip/wheels/2c/4a/61/5599631c1554768c6290b08c02c72d7317910374ca602ff1e5
Running setup.py bdist\PYGZus{}wheel \PYG{k}{for} MarkupSafe: started
Running setup.py bdist\PYGZus{}wheel \PYG{k}{for} MarkupSafe: finished with status \PYG{l+s+s1}{\PYGZsq{}done\PYGZsq{}}
Stored in directory: /root/.cache/pip/wheels/33/56/20/ebe49a5c612fffe1c5a632146b16596f9e64676768661e4e46
Successfully built itsdangerous MarkupSafe
Installing collected packages: itsdangerous, MarkupSafe, Jinja2, Werkzeug, click, Flask, Redis
Successfully installed Flask\PYGZhy{}1.0.2 Jinja2\PYGZhy{}2.10 MarkupSafe\PYGZhy{}1.0 Redis\PYGZhy{}2.10.6 Werkzeug\PYGZhy{}0.14.1 click\PYGZhy{}6.7 itsdangerous\PYGZhy{}0.24
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} e3312707c13d
Removing intermediate container bbf16703da30
Step \PYG{l+m}{5}/7 : EXPOSE \PYG{l+m}{80}
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Running in c70194d4650e
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} cec1a446cca8
Removing intermediate container c70194d4650e
Step \PYG{l+m}{6}/7 : ENV NAME World
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Running in ed2b75276780
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 7e5a33a4fc94
Removing intermediate container ed2b75276780
Step \PYG{l+m}{7}/7 : CMD python app.py
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Running in 7ef196474b9e
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 71c2acc4550b
Removing intermediate container 7ef196474b9e
Successfully built 71c2acc4550b
\end{sphinxVerbatim}


\subsection{运行app}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:app}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker run \PYGZhy{}p \PYG{l+m}{4000}:80 friendlyhello

curl http://localhost:4000
\PYGZlt{}h3\PYGZgt{}Hello World!\PYGZlt{}/h3\PYGZgt{}\PYGZlt{}b\PYGZgt{}Hostname:\PYGZlt{}/b\PYGZgt{} e694031416cb\PYGZlt{}br/\PYGZgt{}\PYGZlt{}b\PYGZgt{}Visits:\PYGZlt{}/b\PYGZgt{} \PYGZlt{}i\PYGZgt{}cannot connect to Redis, counter disabled\PYGZlt{}/i\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{注解:}
上面docker run是默认运行在前台的，-d选项可以指定在后台运行。
\end{sphinxadmonition}


\subsection{关闭app}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:id6}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 查看容器}
docker container ls
    CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES
    e694031416cb        friendlyhello       \PYG{l+s+s2}{\PYGZdq{}python app.py\PYGZdq{}}     \PYG{l+m}{2} minutes ago       Up \PYG{l+m}{2} minutes        \PYG{l+m}{0}.0.0.0:4000\PYGZhy{}\PYGZgt{}80/tcp   relaxed\PYGZus{}boyd

\PYG{c+c1}{\PYGZsh{} 停掉容器}
docker container stop e694031416cb
\end{sphinxVerbatim}


\section{共享你的镜像}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:id7}}

\subsection{登陆dockerhub}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:dockerhub}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} docker login
Login with your Docker ID to push and pull images from Docker Hub. If you don\PYGZsq{}t have a Docker ID, head over to https://hub.docker.com to create one.
Username: zhaojiedi1992
Password:
Login Succeeded
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{注解:}
如果使用自己搭建的docker仓库， login后面跟网址就可以了。
\end{sphinxadmonition}


\subsection{给镜像打tag}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:tag}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker image ls
    REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
    friendlyhello                 latest              71c2acc4550b        \PYG{l+m}{2} hours ago         \PYG{l+m}{132} MB
    docker.io/python              \PYG{l+m}{2}.7\PYGZhy{}slim            7302ff8cae7a        \PYG{l+m}{4} days ago          \PYG{l+m}{120} MB
    docker.io/busybox             glibc               0b09e1ac1503        \PYG{l+m}{13} days ago         \PYG{l+m}{4}.42 MB
    docker.io/jolestar/go\PYGZhy{}probe   latest              cee847b51a27        \PYG{l+m}{5} weeks ago         \PYG{l+m}{36}.8 MB

\PYG{c+c1}{\PYGZsh{} 打tag}
docker tag image username/repository:tag
\end{sphinxVerbatim}


\subsection{推送镜像}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:id8}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker tag friendlyhello zhaojiedi1992/helloworld:v1.0
\end{sphinxVerbatim}


\subsection{拉取并运行自我镜像}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/02-_u5bb9_u5668:id9}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker run \PYGZhy{}p \PYG{l+m}{4000}:80 zhaojiedi1992/helloworld:v1.0
\end{sphinxVerbatim}


\chapter{服务}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/03-_u670d_u52a1::doc}}\label{\detokenize{_u5feb_u901f_u5165_u95e8/03-_u670d_u52a1:id1}}

\section{需要的环境}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/03-_u670d_u52a1:id2}}\begin{itemize}
\item {} 
docker\textgreater{}=1.13

\item {} 
docker compose

\item {} 
已经完成前面2个章节

\end{itemize}


\section{安装docker compose}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/03-_u670d_u52a1:docker-compose}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 配置k8s 仓库}
\PYG{o}{[}root@iZ2ze3vsekthy9vqtndzefZ yum.repos.d\PYG{o}{]}\PYG{c+c1}{\PYGZsh{} cat kubernetes.repo}
\PYG{o}{[}kubernetes\PYG{o}{]}
\PYG{n+nv}{name}\PYG{o}{=}Kubernetes
\PYG{n+nv}{baseurl}\PYG{o}{=}http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes\PYGZhy{}el7\PYGZhy{}x86\PYGZus{}64
\PYG{n+nv}{enabled}\PYG{o}{=}\PYG{l+m}{1}
\PYG{n+nv}{gpgcheck}\PYG{o}{=}\PYG{l+m}{0}
\PYG{n+nv}{repo\PYGZus{}gpgcheck}\PYG{o}{=}\PYG{l+m}{0}
\PYG{n+nv}{gpgkey}\PYG{o}{=}http://mirrors.aliyun.com/kubernetes/yum/doc/yum\PYGZhy{}key.gpg
    http://mirrors.aliyun.com/kubernetes/yum/doc/rpm\PYGZhy{}package\PYGZhy{}key.gpg

\PYG{c+c1}{\PYGZsh{} 开始安装}
yum install docker\PYGZhy{}compose
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{注解:}
默认k8s的仓库是google的，没法访问的。
\end{sphinxadmonition}


\section{docker-compose.yml文件}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/03-_u670d_u52a1:docker-compose-yml}}
编辑一个docker-compose.yml文件，内容如下：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+lScalar+lScalarPlain}{version}\PYG{p+pIndicator}{:} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3}\PYG{l+s}{\PYGZdq{}}
\PYG{l+lScalar+lScalarPlain}{services}\PYG{p+pIndicator}{:}
\PYG{l+lScalar+lScalarPlain}{web}\PYG{p+pIndicator}{:}
    \PYG{c+c1}{\PYGZsh{} replace username/repo:tag with your name and image details}
    \PYG{l+lScalar+lScalarPlain}{image}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{zhaojiedi1992/helloworld:v1.0}
    \PYG{l+lScalar+lScalarPlain}{deploy}\PYG{p+pIndicator}{:}
    \PYG{l+lScalar+lScalarPlain}{replicas}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{5}
    \PYG{l+lScalar+lScalarPlain}{resources}\PYG{p+pIndicator}{:}
        \PYG{l+lScalar+lScalarPlain}{limits}\PYG{p+pIndicator}{:}
        \PYG{l+lScalar+lScalarPlain}{cpus}\PYG{p+pIndicator}{:} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.1}\PYG{l+s}{\PYGZdq{}}
        \PYG{l+lScalar+lScalarPlain}{memory}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{50M}
    \PYG{l+lScalar+lScalarPlain}{restart\PYGZus{}policy}\PYG{p+pIndicator}{:}
        \PYG{l+lScalar+lScalarPlain}{condition}\PYG{p+pIndicator}{:} \PYG{l+lScalar+lScalarPlain}{on\PYGZhy{}failure}
    \PYG{l+lScalar+lScalarPlain}{ports}\PYG{p+pIndicator}{:}
    \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4000:80}\PYG{l+s}{\PYGZdq{}}
    \PYG{l+lScalar+lScalarPlain}{networks}\PYG{p+pIndicator}{:}
    \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{webnet}
\PYG{l+lScalar+lScalarPlain}{networks}\PYG{p+pIndicator}{:}
\PYG{l+lScalar+lScalarPlain}{webnet}\PYG{p+pIndicator}{:}
\end{sphinxVerbatim}


\section{运行一个负载均衡的app}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/03-_u670d_u52a1:app}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}

{[}\sphinxhref{mailto:root@iZ2ze3vsekthy9vqtndzefZ}{root@iZ2ze3vsekthy9vqtndzefZ} docker{]}\#  docker swarm init \textendash{}advertise-addr 10.80.89.19

{[}\sphinxhref{mailto:root@iZ2ze3vsekthy9vqtndzefZ}{root@iZ2ze3vsekthy9vqtndzefZ} docker{]}\# docker stack deploy -c docker-compose.yml getstartedlab
Creating network getstartedlab\_webnet
Creating service getstartedlab\_web

{[}\sphinxhref{mailto:root@iZ2ze3vsekthy9vqtndzefZ}{root@iZ2ze3vsekthy9vqtndzefZ} docker{]}\# docker service ls
ID            NAME               MODE        REPLICAS  IMAGE
hf9hawqrchfq  getstartedlab\_web  replicated  5/5       zhaojiedi1992/helloworld:v1.0

{[}\sphinxhref{mailto:root@iZ2ze3vsekthy9vqtndzefZ}{root@iZ2ze3vsekthy9vqtndzefZ} docker{]}\# docker service ps getstartedlab\_web
ID            NAME                 IMAGE                          NODE                     DESIRED STATE  CURRENT STATE               ERROR  PORTS
pv5j41ap4btg  getstartedlab\_web.1  zhaojiedi1992/helloworld:v1.0  iZ2ze3vsekthy9vqtndzefZ  Running        Running about a minute ago
rsvlvfa48sk6  getstartedlab\_web.2  zhaojiedi1992/helloworld:v1.0  iZ2ze3vsekthy9vqtndzefZ  Running        Running about a minute ago
od33frib2yxs  getstartedlab\_web.3  zhaojiedi1992/helloworld:v1.0  iZ2ze3vsekthy9vqtndzefZ  Running        Running about a minute ago
z2til8qa79k0  getstartedlab\_web.4  zhaojiedi1992/helloworld:v1.0  iZ2ze3vsekthy9vqtndzefZ  Running        Running about a minute ago
29tnd4g7p8kj  getstartedlab\_web.5  zhaojiedi1992/helloworld:v1.0  iZ2ze3vsekthy9vqtndzefZ  Running        Running about a minute ago


\section{扩展应用程序}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/03-_u670d_u52a1:id3}}
修改docker-compose的集群数值，然后运行如下命令：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker stack deploy \PYGZhy{}c docker\PYGZhy{}compose.yml getstartedlab
\end{sphinxVerbatim}


\section{关闭app和swarm}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/03-_u670d_u52a1:appswarm}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker stack rm getstartedlab
docker swarm leave \PYGZhy{}\PYGZhy{}force
\end{sphinxVerbatim}


\chapter{swarms}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/04-swarms::doc}}\label{\detokenize{_u5feb_u901f_u5165_u95e8/04-swarms:swarms}}

\section{理解swarm集群}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/04-swarms:swarm}}
群集是一组运行Docker并加入群集的计算机。在此之后，您继续运行您习惯使用的Docker命令，但现在它们由群集管理器在群集上执行。
群中的机器可以是物理的或虚拟的。加入群组后，它们被称为节点。

Swarm管理器可以使用多种策略来运行容器，例如“最节点的节点” - 它使用容器填充利用率最低的机器。或“全局”，它确保每台机器只获得指定容器的一个实例。
您指示swarm管理器在Compose文件中使用这些策略，就像您已经使用的那样。

群集管理器是群中唯一可以执行命令的机器，或授权其他机器作为工作者加入群集。工人只是在那里提供能力，并且没有权力告诉任何其他机器它能做什么和不能做什么。

到目前为止，您一直在本地计算机上以单主机模式使用Docker。但是Docker也可以切换到swarm模式，这就是使用群集的能力。立即启用群集模式使当前计算机成为群集管理器。
从那时起，Docker就会运行您在管理的swarm上执行的命令，而不仅仅是在当前机器上。


\section{设置swarm}
\label{\detokenize{_u5feb_u901f_u5165_u95e8/04-swarms:id1}}
管理端使用docker swarm init ,其他节点使用docker swarm join


\chapter{docker部署最佳实践}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/01-_u90e8_u7f72_u5e94_u7528::doc}}\label{\detokenize{_u8fd0_u884c_u5e94_u7528/01-_u90e8_u7f72_u5e94_u7528:docker}}

\section{如何让你的镜像更小}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/01-_u90e8_u7f72_u5e94_u7528:id1}}\begin{itemize}
\item {} 
选择合适的基础镜像，如果你需要jdk环境，建议直接选择openjdk作为基础镜像，而不是选择ubuntu镜像后按照openjdk在dockerfile中。

\item {} 
使用多级构建，多条相同命令合并为一条命令，减少构建层级。

\item {} 
如果多个镜像有大量相同的功能，可以考虑根据相同的功能创建一个基础镜像。

\item {} 
为了保持生产镜像的精简，你可以创建一个精简镜像，以精简镜像为基础镜像安装调试工具包。

\item {} 
构建镜像，总是使用tags进行编写描述信息。

\end{itemize}


\section{怎么让数据持久化}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/01-_u90e8_u7f72_u5e94_u7528:id2}}\begin{itemize}
\item {} 
避免使用容器的存储，使用卷或者绑定挂载功能。

\item {} 
开发期间可以使用bind mount来挂载需要的挂载二进制文件到容器中，生产环境请使用卷。

\item {} 
对于生产，加密重要信息，使用configs配置非机密配置文件。

\end{itemize}


\section{尽可能使用swarm服务}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/01-_u90e8_u7f72_u5e94_u7528:swarm}}

\section{使用CI/CD去测试和部署}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/01-_u90e8_u7f72_u5e94_u7528:ci-cd}}\begin{itemize}
\item {} 
当您检查对源代码管理的更改或创建拉取请求时，请使用Docker Cloud或其他CI / CD管道自动构建和标记Docker镜像并对其进行测试。

\end{itemize}


\section{开发和生产采用不同环境}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/01-_u90e8_u7f72_u5e94_u7528:id3}}\begin{itemize}
\item {} 
开发采用bind mounts ，生产采用卷。

\item {} 
开发不用关心时间同步信息，生产环境一个集群确保采用同一个ntp server。

\end{itemize}


\chapter{dockerfile编写最佳实践}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5::doc}}\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:dockerfile}}

\section{一般准则和建议}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:id1}}\begin{itemize}
\item {} 
创建尽可能精简的容器

\item {} 
了解构建上下文

\item {} 
通过stdin管道Dockerfile

\item {} 
包含dockerignore文件

\item {} 
使用多阶段构建

\item {} 
不要安装不必要的包

\item {} 
解构应用程序，分离容器功能，每个容器限制为单个进程，保存容器的清洁和模块化，容器直接可以通过网络通信。

\item {} 
最小化层级

\item {} 
一个命令可以使用转义为多行，美化dockerfile文件。让别人看起来舒服点。

\item {} 
利用构建缓存

\end{itemize}


\section{通过stdin管道Dockerfile的样例}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:stdindockerfile}}
docker\textless{}17.04

docker\textgreater{}=17.05 local

docker\textgreater{}=17.05 remote

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker build \PYGZhy{}t foo \PYGZhy{}\PYG{l+s}{\PYGZlt{}\PYGZlt{}EOF}
\PYG{l+s}{FROM busybox}
\PYG{l+s}{RUN echo \PYGZdq{}hello world\PYGZdq{}}
\PYG{l+s}{EOF}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker build \PYGZhy{}t foo . \PYGZhy{}f\PYGZhy{}\PYG{l+s}{\PYGZlt{}\PYGZlt{}EOF}
\PYG{l+s}{FROM busybox}
\PYG{l+s}{RUN echo \PYGZdq{}hello world\PYGZdq{}}
\PYG{l+s}{COPY . /my\PYGZhy{}copied\PYGZhy{}files}
\PYG{l+s}{EOF}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker build \PYGZhy{}t foo https://github.com/thajeztah/pgadmin4\PYGZhy{}docker.git \PYGZhy{}f\PYGZhy{}\PYG{l+s}{\PYGZlt{}\PYGZlt{}EOF}
\PYG{l+s}{FROM busybox}
\PYG{l+s}{COPY LICENSE config\PYGZus{}local.py /usr/local/lib/python2.7/site\PYGZhy{}packages/pgadmin4/}
\PYG{l+s}{EOF}
\end{sphinxVerbatim}


\section{docker指令}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:docker}}

\subsection{FROM}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:from}}
尽量选择alpine镜像作为源镜像，这样构建的镜像才最小


\subsection{LABEL}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:label}}
LABEL用来说明我们的镜像信息的，尽可能的详细点。

比较详细的dockerfile label

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Set one or more individual labels}
LABEL com.example.version\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}0.0.1\PYGZhy{}beta\PYGZdq{}}
LABEL \PYG{n+nv}{vendor1}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}ACME Incorporated\PYGZdq{}}
LABEL \PYG{n+nv}{vendor2}\PYG{o}{=}ZENITH\PYG{l+s+se}{\PYGZbs{} }Incorporated
LABEL com.example.release\PYGZhy{}date\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}2015\PYGZhy{}02\PYGZhy{}12\PYGZdq{}}
LABEL com.example.version.is\PYGZhy{}production\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\end{sphinxVerbatim}

但是上面的label会构建多层的。需要改进为如下风格的。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
LABEL \PYG{n+nv}{vendor}\PYG{o}{=}ACME\PYG{l+s+se}{\PYGZbs{} }Incorporated \PYG{l+s+se}{\PYGZbs{}}
    com.example.is\PYGZhy{}beta\PYG{o}{=} \PYG{l+s+se}{\PYGZbs{}}
    com.example.is\PYGZhy{}production\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{}}
    com.example.version\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}0.0.1\PYGZhy{}beta\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{}}
    com.example.release\PYGZhy{}date\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}2015\PYGZhy{}02\PYGZhy{}12\PYGZdq{}}
\end{sphinxVerbatim}


\subsection{RUN}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:run}}
使用来分割命令为多行，来增加可读性和可维护性。


\subsection{USING PIPES}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:using-pipes}}
docker使用/bin/sh -c来解释run命令，该解释器仅仅评估管道中最后一个的操作码来确定成功，

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 即使wget失败，后续的wc \PYGZhy{}l成功，整句的就是成功的。}
\PYG{k}{RUN} wget \PYGZhy{}O \PYGZhy{} https://some.site \PYG{p}{\textbar{}} wc \PYGZhy{}l \PYGZgt{} /number
\end{sphinxVerbatim}


\subsection{CMD}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:cmd}}
CMD 尽可能采用数组形式的，且只提供参数，具体的命令使用ENDPOINT指定。


\subsection{EXPOSE}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:expose}}

\subsection{ENV}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:env}}
为了确保你的应用程序以比较简单的方式去运行，可以使用env去添加环境变量。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{ENV}\PYG{l+s}{ PATH /usr/local/nginx/bin:\PYGZdl{}PATH}
\PYG{k}{CMD}\PYG{l+s}{ [\PYGZdq{}nginx\PYGZdq{}]}
\end{sphinxVerbatim}

每个ENV会添加一层，可以一次添加多个行间变量。可以使用run来替代ENV

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{FROM}\PYG{l+s}{ alpine}
\PYG{k}{RUN} \PYG{n+nb}{export} \PYG{n+nv}{ADMIN\PYGZus{}USER}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}mark\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{}}
    \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}ADMIN\PYGZus{}USER} \PYGZgt{} ./mark \PYG{l+s+se}{\PYGZbs{}}
    \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n+nb}{unset} ADMIN\PYGZus{}USER
\PYG{k}{CMD}\PYG{l+s}{ sh}
\end{sphinxVerbatim}


\subsection{ADD or COPY}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:add-or-copy}}
ADD和COPY都可以完成文件的copy工作。 但是ADD可以下载网络资源，并可以自动完成解压到特定目录去。
强烈建议不要使用ADD从远程URL中获取包。 你应该使用curl或wget代替,样例如下。

错误做法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}

ADD \sphinxurl{http://example.com/big.tar.xz} /usr/src/things/
RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things
RUN make -C /usr/src/things all

替代做法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{RUN} mkdir \PYGZhy{}p /usr/src/things \PYG{l+s+se}{\PYGZbs{}}
    \PYG{o}{\PYGZam{}\PYGZam{}} curl \PYGZhy{}SL http://example.com/big.tar.xz \PYG{l+s+se}{\PYGZbs{}}
    \PYG{p}{\textbar{}} tar \PYGZhy{}xJC /usr/src/things \PYG{l+s+se}{\PYGZbs{}}
    \PYG{o}{\PYGZam{}\PYGZam{}} make \PYGZhy{}C /usr/src/things all
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{注解:}
如果不需要add的自动解压功能，你应该始终使用COPY。
\end{sphinxadmonition}


\subsection{ENTRYPOINT}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:entrypoint}}
ENTRYPOINT用于定义程序的主命令，CMD用来定义给ENTRYPOINT的参数，且2中都采用数组形式。

exec用于执行一个新命令去替换现有进程，可以保证我们的进程启动在pid为1 。


\subsection{VOLUME}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:volume}}
使用卷去存储数据库数据，或者配置文件等。


\subsection{USER}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:user}}
可以指定一个非root的用户作为容器的运行身份。


\subsection{WORKDIR}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:workdir}}
写WORKDIR请采用绝对路径，采用相对路径会增加维护和故障排查问题。


\subsection{ONBUILD}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/02-dockerfile_u7f16_u5199_u6700_u4f73_u5b9e_u8df5:onbuild}}
ONBUILD命令是执行在当前dockefile构建完毕的镜像被别人作为基础镜像后的执行脚本。


\chapter{创建一个基础镜像}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/03-_u521b_u5efa_u4e00_u4e2a_u57fa_u7840_u955c_u50cf::doc}}\label{\detokenize{_u8fd0_u884c_u5e94_u7528/03-_u521b_u5efa_u4e00_u4e2a_u57fa_u7840_u955c_u50cf:id1}}

\chapter{使用多步构建}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/04-_u4f7f_u7528_u591a_u6b65_u6784_u5efa::doc}}\label{\detokenize{_u8fd0_u884c_u5e94_u7528/04-_u4f7f_u7528_u591a_u6b65_u6784_u5efa:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{FROM}\PYG{l+s}{ golang:1.7.3}
\PYG{k}{WORKDIR}\PYG{l+s}{ /go/src/github.com/alexellis/href\PYGZhy{}counter/}
\PYG{k}{RUN} go get \PYGZhy{}d \PYGZhy{}v golang.org/x/net/html
COPY app.go .
\PYG{k}{RUN} \PYG{n+nv}{CGO\PYGZus{}ENABLED}\PYG{o}{=}\PYG{l+m}{0} \PYG{n+nv}{GOOS}\PYG{o}{=}linux go build \PYGZhy{}a \PYGZhy{}installsuffix cgo \PYGZhy{}o app .

\PYG{k}{FROM}\PYG{l+s}{ alpine:latest}
\PYG{k}{RUN} apk \PYGZhy{}\PYGZhy{}no\PYGZhy{}cache add ca\PYGZhy{}certificates
\PYG{k}{WORKDIR}\PYG{l+s}{ /root/}
COPY \PYGZhy{}\PYGZhy{}from\PYG{o}{=}\PYG{l+m}{0} /go/src/github.com/alexellis/href\PYGZhy{}counter/app .
\PYG{k}{CMD}\PYG{l+s}{ [\PYGZdq{}./app\PYGZdq{}]}
\end{sphinxVerbatim}


\chapter{dockerfile参考}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003::doc}}\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:dockerfile}}

\section{使用}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker build
docker build \PYGZhy{}t zhaojiedi1992/helloworld:v1.0 \PYGZhy{}t zhaojiedi1992/helloworld:latest  \PYGZhy{}f  \PYGZhy{}f /path/to/a/Dockerfile .
\end{sphinxVerbatim}


\section{注释}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:id2}}
dockefile中注释使用\#开头。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 这是一个注释行}
\end{sphinxVerbatim}


\section{转义}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:id3}}
dockerfile中使用来转义空格、换行符等。


\section{环境变量替换}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:id4}}
环境变量通过ENV指定，支持bash操作的。比如\$\{foo\},\$\{foo-abc\}等

可以使用环境变量的片段为:
\begin{itemize}
\item {} 
ADD

\item {} 
COPY

\item {} 
ENV

\item {} 
EXPOSE

\item {} 
FROM

\item {} 
LABEL

\item {} 
STOPSIGNAL

\item {} 
USER

\item {} 
VOLUME

\item {} 
WORKDIR

\end{itemize}

\begin{sphinxadmonition}{note}{注解:}
在1.4版本之后，ONBUILD也支持使用环境变量了。
\end{sphinxadmonition}


\section{.dockerignore文件}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:dockerignore}}
dockerfile 主要配合add,copy使用，包含在dockerignore的配置被过滤掉的。具体的语法类似gitignore文件。


\section{FROM}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:from}}
FROM用于指定基础镜像的名字。

用法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{FROM}\PYG{l+s}{ \PYGZlt{}image\PYGZgt{} [AS \PYGZlt{}name\PYGZgt{}]}
\PYG{k}{FROM}\PYG{l+s}{ \PYGZlt{}image\PYGZgt{}[:\PYGZlt{}tag\PYGZgt{}] [AS \PYGZlt{}name\PYGZgt{}]}
\PYG{k}{FROM}\PYG{l+s}{ \PYGZlt{}image\PYGZgt{}[@\PYGZlt{}digest\PYGZgt{}] [AS \PYGZlt{}name\PYGZgt{}]}
\end{sphinxVerbatim}

使用样例

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
ARG  \PYG{n+nv}{CODE\PYGZus{}VERSION}\PYG{o}{=}latest
\PYG{k}{FROM}\PYG{l+s}{ base:\PYGZdl{}\PYGZob{}CODE\PYGZus{}VERSION\PYGZcb{}}
\PYG{k}{CMD}\PYG{l+s}{  /code/run\PYGZhy{}app}
\end{sphinxVerbatim}

ARG不同于ENV的，ARG作用于docker命令构建的时候，ENV是在镜像构建后，实例化的时候运行的。


\section{RUN}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:run}}
RUN有2种格式用法

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{RUN} \PYGZlt{}command\PYGZgt{}
\PYG{k}{RUN} \PYG{o}{[}\PYG{l+s+s2}{\PYGZdq{}executable\PYGZdq{}}, \PYG{l+s+s2}{\PYGZdq{}param1\PYGZdq{}}, \PYG{l+s+s2}{\PYGZdq{}param2\PYGZdq{}}\PYG{o}{]}
\end{sphinxVerbatim}


\section{CMD}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:cmd}}
CMD有三种格式用法。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CMD}\PYG{l+s}{ [\PYGZdq{}executable\PYGZdq{},\PYGZdq{}param1\PYGZdq{},\PYGZdq{}param2\PYGZdq{}]}
\PYG{k}{CMD}\PYG{l+s}{ [\PYGZdq{}param1\PYGZdq{},\PYGZdq{}param2\PYGZdq{}]}
\PYG{k}{CMD}\PYG{l+s}{ command param1 param2}
\end{sphinxVerbatim}


\section{LABEL}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:label}}
LABEL用于定义描述信息。是一个key,value对

用法:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
LABEL \PYGZlt{}key\PYGZgt{}\PYG{o}{=}\PYGZlt{}value\PYGZgt{} \PYGZlt{}key\PYGZgt{}\PYG{o}{=}\PYGZlt{}value\PYGZgt{} \PYGZlt{}key\PYGZgt{}\PYG{o}{=}\PYGZlt{}value\PYGZgt{} ...
\end{sphinxVerbatim}

定义的LABEL信息，可以通过docker inspect命令获取镜像的LABEL信息。


\section{MAINTAINER (已经弃用了)}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:maintainer}}
使用如下设置维护者。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
LABEL \PYG{n+nv}{maintainer}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}SvenDowideit@home.org.au\PYGZdq{}}
\end{sphinxVerbatim}


\section{EXPOSE}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:expose}}
用于指定需要暴露的的端口，用法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{EXPOSE}\PYG{l+s}{ \PYGZlt{}port\PYGZgt{} [\PYGZlt{}port\PYGZgt{}/\PYGZlt{}protocol\PYGZgt{}...]}
\end{sphinxVerbatim}

样例：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{EXPOSE}\PYG{l+s}{ 80/tcp}
\PYG{k}{EXPOSE}\PYG{l+s}{ 80/udp}
\end{sphinxVerbatim}

我们可以在docker运行时重设这些设置信息。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker run \PYGZhy{}p \PYG{l+m}{80}:80/tcp \PYGZhy{}p \PYG{l+m}{80}:80/udp ...
\end{sphinxVerbatim}


\section{ENV}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:env}}
用于定义运行时的变量

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{ENV}\PYG{l+s}{ \PYGZlt{}key\PYGZgt{} \PYGZlt{}value\PYGZgt{}}
\PYG{k}{ENV}\PYG{l+s}{ \PYGZlt{}key\PYGZgt{}=\PYGZlt{}value\PYGZgt{} ...}
\end{sphinxVerbatim}

样例：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{ENV}\PYG{l+s}{ myName=\PYGZdq{}John Doe\PYGZdq{} myDog=Rex\PYGZbs{} The\PYGZbs{} Dog \PYGZbs{}}
    \PYG{n+nv}{myCat}\PYG{o}{=}fluffy
\end{sphinxVerbatim}


\section{ADD}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:add}}
用于从当前的目录复制文件到镜像中去

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
ADD [\PYGZhy{}\PYGZhy{}chown=\PYGZlt{}user\PYGZgt{}:\PYGZlt{}group\PYGZgt{}] \PYGZlt{}src\PYGZgt{}... \PYGZlt{}dest\PYGZgt{}
ADD [\PYGZhy{}\PYGZhy{}chown=\PYGZlt{}user\PYGZgt{}:\PYGZlt{}group\PYGZgt{}] [\PYGZdq{}\PYGZlt{}src\PYGZgt{}\PYGZdq{},... \PYGZdq{}\PYGZlt{}dest\PYGZgt{}\PYGZdq{}]
\end{sphinxVerbatim}


\section{COPY}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:copy}}
用于从当前的目录复制文件到镜像中去

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
COPY \PYG{o}{[}\PYGZhy{}\PYGZhy{}chown\PYG{o}{=}\PYGZlt{}user\PYGZgt{}:\PYGZlt{}group\PYGZgt{}\PYG{o}{]} \PYGZlt{}src\PYGZgt{}... \PYGZlt{}dest\PYGZgt{}
COPY \PYG{o}{[}\PYGZhy{}\PYGZhy{}chown\PYG{o}{=}\PYGZlt{}user\PYGZgt{}:\PYGZlt{}group\PYGZgt{}\PYG{o}{]} \PYG{o}{[}\PYG{l+s+s2}{\PYGZdq{}\PYGZlt{}src\PYGZgt{}\PYGZdq{}},... \PYG{l+s+s2}{\PYGZdq{}\PYGZlt{}dest\PYGZgt{}\PYGZdq{}}\PYG{o}{]}
\end{sphinxVerbatim}


\section{ENTRYPOINT}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:entrypoint}}
ENTRYPOINT用于定义进入点，用法2种。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{ENTRYPOINT}\PYG{l+s}{ [\PYGZdq{}executable\PYGZdq{}, \PYGZdq{}param1\PYGZdq{}, \PYGZdq{}param2\PYGZdq{}]}
\PYG{k}{ENTRYPOINT}\PYG{l+s}{ command param1 param2}
\end{sphinxVerbatim}

样例：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{FROM}\PYG{l+s}{ ubuntu}
\PYG{k}{ENTRYPOINT}\PYG{l+s}{ [\PYGZdq{}top\PYGZdq{}, \PYGZdq{}\PYGZhy{}b\PYGZdq{}]}
\PYG{k}{CMD}\PYG{l+s}{ [\PYGZdq{}\PYGZhy{}c\PYGZdq{}]}
\end{sphinxVerbatim}

如果docker运行的时候想重写ENTRYPOINT,可以指定\textendash{}entrypoint 选项。

ENTRYPOINT 和CMD


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
ENTRYPOINT     “ENTRYPOINT exec\_entry p1\_entry”
&\sphinxstyletheadfamily 
ENTRYPOINT {[}exec\_entry, p1\_entry{]}
&\sphinxstyletheadfamily \\
\hline
No CMD
&
error, not allowed
&
/bin/sh -c exec\_entry p1\_entry
&
exec\_entry p1\_entry
\\
\hline
CMD {[}exec\_cmd, p1\_cmd{]}
&
exec\_cmd p1\_cmd
&
/bin/sh -c exec\_entry p1\_entry
&
exec\_entry p1\_entry exec\_cmd p1\_cmd
\\
\hline
CMD {[}p1\_cmd, p2\_cmd{]}
&
p1\_cmd p2\_cmd
&
/bin/sh -c exec\_entry p1\_entry
&
exec\_entry p1\_entry p1\_cmd p2\_cmd
\\
\hline
CMD exec\_cmd p1\_cmd
&
/bin/sh -c exec\_cmd p1\_cmd
&
/bin/sh -c exec\_entry p1\_entry
&
exec\_entry p1\_entry /bin/sh -c exec\_cmd p1\_cmd
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{VOLUME}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:volume}}
用于设置卷，用法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{VOLUME}\PYG{l+s}{ [\PYGZdq{}/data\PYGZdq{}]}
\end{sphinxVerbatim}


\section{USER}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:user}}
设置运行的用户身份，用法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
USER \PYGZlt{}user\PYGZgt{}\PYG{o}{[}:\PYGZlt{}group\PYGZgt{}\PYG{o}{]} or
USER \PYGZlt{}UID\PYGZgt{}\PYG{o}{[}:\PYGZlt{}GID\PYGZgt{}\PYG{o}{]}
\end{sphinxVerbatim}


\section{WORKDIR}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:workdir}}
设置工作目录，对RUN,CMD,ENTRYPOINT,COPY,ADD都是有影响的。

样例：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{WORKDIR}\PYG{l+s}{ /a}
\PYG{k}{WORKDIR}\PYG{l+s}{ b}
\PYG{k}{WORKDIR}\PYG{l+s}{ c}
\PYG{k}{RUN} pwd
\end{sphinxVerbatim}

上面的打印结果为/a/b/c的。


\section{ARG}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:arg}}
ARG用于指定参数，用法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
ARG \PYGZlt{}name\PYGZgt{}\PYG{o}{[}\PYG{o}{=}\PYGZlt{}default value\PYGZgt{}\PYG{o}{]}
\end{sphinxVerbatim}

样例：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker build \PYGZhy{}\PYGZhy{}build\PYGZhy{}arg \PYGZlt{}varname\PYGZgt{}\PYG{o}{=}\PYGZlt{}value\PYGZgt{}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{FROM}\PYG{l+s}{ ubuntu}
ARG CONT\PYGZus{}IMG\PYGZus{}VER
\PYG{k}{ENV}\PYG{l+s}{ CONT\PYGZus{}IMG\PYGZus{}VER \PYGZdl{}\PYGZob{}CONT\PYGZus{}IMG\PYGZus{}VER:\PYGZhy{}v1.0.0\PYGZcb{}}
\PYG{k}{RUN} \PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}CONT\PYGZus{}IMG\PYGZus{}VER}
\end{sphinxVerbatim}


\section{ONBUILD}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:onbuild}}
ONBUILD会在此镜像作为其他镜像的基础镜像的时候被执行。

构建步骤：
\begin{enumerate}
\item {} 
当遇到ONBUILD指令时，构建器会向正在构建的镜像的元数据添加触发器。 该指令不会影响当前构建。

\item {} 
在构建结束时，所有触发器的列表都存储在映像清单中的OnBuild键下。 可以使用docker inspect命令检查它们。

\item {} 
稍后，可以使用FROM指令将镜像用作新构建的基础。 作为处理FROM指令的一部分，下游构建器查找ONBUILD触发器，并按照它们注册的顺序执行它们。
如果任何触发器失败，则中止FROM指令，这反过来导致构建失败。 如果所有触发器都成功，则FROM指令完成，并且构建继续照常进行。

\item {} 
执行后，触发器将从最终镜像中清除。

\end{enumerate}

样例：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}...\PYG{o}{]}
\PYG{n+nKeyword}{ONBUILD}\PYG{+w}{ }\PYG{k}{ADD} . /app/src
ONBUILD RUN /usr/local/bin/python\PYGZhy{}build \PYGZhy{}\PYGZhy{}dir /app/src
\PYG{o}{[}...\PYG{o}{]}
\end{sphinxVerbatim}


\section{STOPSIGNAL}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:stopsignal}}
设置发送的信号。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
STOPSIGNAL SIGKILL
\end{sphinxVerbatim}


\section{HEALTHCHECK}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:healthcheck}}
提供健康检查功能，用法：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
HEALTHCHECK \PYG{o}{[}OPTIONS\PYG{o}{]} CMD command
HEALTHCHECK NONE

    \PYGZsh{} 选项有
    \PYGZhy{}\PYGZhy{}interval\PYG{o}{=}DURATION \PYG{o}{(}default: 30s\PYG{o}{)}
    \PYGZhy{}\PYGZhy{}timeout\PYG{o}{=}DURATION \PYG{o}{(}default: 30s\PYG{o}{)}
    \PYGZhy{}\PYGZhy{}start\PYGZhy{}period\PYG{o}{=}DURATION \PYG{o}{(}default: 0s\PYG{o}{)}
    \PYGZhy{}\PYGZhy{}retries\PYG{o}{=}N \PYG{o}{(}default: \PYG{l+m}{3}\PYG{o}{)}
\end{sphinxVerbatim}


\section{SHELL}
\label{\detokenize{_u8fd0_u884c_u5e94_u7528/05-dockerfile_u53c2_u8003:shell}}
指定shell的，用法。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
SHELL \PYG{o}{[}\PYG{l+s+s2}{\PYGZdq{}executable\PYGZdq{}}, \PYG{l+s+s2}{\PYGZdq{}parameters\PYGZdq{}}\PYG{o}{]}
\PYG{c}{\PYGZsh{} 在linux下为  [\PYGZdq{}/bin/sh\PYGZdq{}, \PYGZdq{}\PYGZhy{}c\PYGZdq{}]}
\PYG{c}{\PYGZsh{} 在window下为 [\PYGZdq{}cmd\PYGZdq{}, \PYGZdq{}/S\PYGZdq{}, \PYGZdq{}/C\PYGZdq{}]}
\end{sphinxVerbatim}



\renewcommand{\indexname}{索引}
\printindex
\end{document}